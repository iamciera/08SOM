itag.sc <- as.data.frame(sub_cluster$gene)
colnames(itag.sc)[1] <- "itag"
itag.sc$sc <- 1
#Since each orthologue between tf2 and wt are represented twice in this set, we have to keep only the unique ITAGs.
itag.sc <- unique(itag.sc) #Check. Should cut the list in half. # dim(itag.sc) before and after
#Merge all by itag
matrixGO <- merge(itag.sc, geneLength, by = "itag", all = TRUE)
matrixGO[is.na(matrixGO)] <- 0
pat <- matrixGO
#Now that we have the data in the right format we can proceed with GO enrichment.
genes = as.integer(pat[,"sc"])
names(genes) = pat$itag
table(genes)
length(genes)
pwf = nullp(genes,bias.data=pat$length)
GO.wall = goseq(pwf,gene2cat = cate)
head(GO.wall)
#This is going to correct for multiple testing.  You can specify the p-value cut-off of GO categories you are interested.
enriched.GO = GO.wall$category[p.adjust(GO.wall$over_represented_pvalue, method = "BH") < 0.05]
enriched.GO
my.GO <- as.character(enriched.GO)
my.GO.table <- Term(my.GO)
my.GO.table
t <- as.matrix(my.GO.table)
print(t) #this is for the knitr document
}
```
```{r}
clusterVis_line <- function(clustNum) {
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
sub_data <- sub_cluster[,c(1, 2, 9:14)] # just the sample types
sub_data <- melt(sub_data)
sub_data <- within(sub_data, lineGroup <- paste(genotype, gene,sep='.'))
ggplot(sub_data, aes(variable, value, group = lineGroup, color =  genotype )) +
geom_line(alpha = .1, (aes(color = factor(genotype)))) +
geom_point(alpha = .0)
}
annotation1<- read.delim("../../../06diffGeneExp/analysis/data/ITAG2.3_all_Arabidopsis_ITAG_annotations.tsv", header=FALSE)  #Changed to the SGN human readable annotation
colnames(annotation1) <- c("ITAG", "SGN_annotation")
annotation2<- read.delim ("../../../06diffGeneExp/analysis/data/ITAG2.3_all_Arabidopsis_annotated.tsv")
annotation <- merge(annotation1,annotation2, by = "ITAG")
#Only Gene Name and ITAG
annotation <- annotation[,c(1,5)]
}
(1)
clusterVis_line(1)
clusterVis_line(2)
clusterVis_line(3)
clusterVis_line(4)
clusterGO(4)
clusterVis_line(4)
clusterVis(4)
clusterVis_line(4)
clusterVis_line(5)
clusterVis_line(4)
y <- genesInClust(4, plot.data, annotation)
clusterGO(6)
mostDEgenes <- read.csv("../data/allGeneList.csv")
mostDEgenes <- mostDEgenes[c(7, 1, 4)] #keep only needed columns (gene, type, mean)
#Change from long to wide data format
mostDEgene.long <- cast(mostDEgenes, gene ~ type, value.var = mean, fun.aggregate = "mean")  #why did I have to specify "mean" here? Are there duplicates of types? Double check later.
mostDEgene.long <- as.data.frame(mostDEgene.long)
scale_data <- as.matrix(t(scale(t(mostDEgene.long[c(2:7)]))))#transformation.
#Principle Component Analysis
pca <- prcomp(scale_data, scale=TRUE)
summary(pca)
pca.scores <- data.frame(pca$x)
data.val <- cbind(mostDEgene.long, scale_data, pca.scores)
head(data.val)
countData <- read.csv("../data/normalized_read_count.csv")
head(countData)
countData$genotype <- ifelse(grepl("wt", countData$sample, ignore.case = T), "wt",
ifelse(grepl("tf2", countData$sample, ignore.case = T), "tf2", "unknown"))
#set tissue
countData$tissue <- ifelse(grepl("other", countData$sample, ignore.case = T), "other",
ifelse(grepl("mbr", countData$sample, ignore.case = T), "mbr", "unknown"))
#Set Region
countData$region <- ifelse(grepl("a", countData$sample, ignore.case = T), "A",
ifelse(grepl("c", countData$sample, ignore.case = T), "C", "B"))
#Set type
countData$type <- paste(countData$region, countData$tissue,  sep = "")
head(countData)
#Subset by Genotype, since we will not be looking at tf2 at this stage
countData <- subset(countData, genotype == "wt")
head(countData)
for(GENE in allGenesITAG) {
if(length(grep(GENE, countData$gene)) < 1){ #this is just making sure that the list of sig genes
next;
}
geneData <- subset(countData, grepl(GENE, countData$gene))
sumGraph <- ddply(geneData, c("type", "genotype"), summarise,
N    = length(count),
mean = mean(count),
sd   = sd(count),
se   = sd / sqrt(N))
sumGraph$gene <- GENE
allGeneList  <- rbind(allGeneList, sumGraph) #bind together all the new rows per loop.
}
dim(allGeneList)
head(allGeneList)
write.table(allGeneList, file = "../data/allGeneList.csv", sep = ",")
mostDEgenes <- read.csv("../data/allGeneList.csv")
head(most)
head(mostDEgenes)
mostDEgenes <- mostDEgenes[c(7, 1, 4)] #keep only needed columns (gene, type, mean)
head(mostDEgenes)
mostDEgenes <- read.csv("../data/allGeneList.csv")
head(mostDEgenes)
mostDEgenes <- mostDEgenes[c(7, 1, 4)] #keep only needed columns (gene, type, mean)
head(mostDEgenes)
#Change from long to wide data format
mostDEgene.long <- cast(mostDEgenes, gene ~ type, value.var = mean, fun.aggregate = "mean")  #why did I have to specify "mean" here? Are there duplicates of types? Double check later.
mostDEgene.long <- as.data.frame(mostDEgene.long)
pca <- prcomp(scale_data, scale=TRUE)
summary(pca)
data.val <- cbind(mostDEgene.long, scale_data, pca.scores)
head(data.val)
plot.data <- read.table("../data/ssom.data.analysis5c.txt",header=TRUE)
names(plot.data)
dim(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(ssom.unit.classif)))
p + geom_point() + theme_bw()
p <- ggplot(data.val, aes(PC1, PC2))
p + geom_point()
allGenes <- read.csv("../data/analysis02_geneList.csv")
head(allGenes)
dim(allGenes)
allGenes <- allGenes[c(7, 1, 4)] #keep only needed columns (gene, type, mean)
summary(allGenes)
head(allGenes)
#Change from long to wide data format
allGene.long <- cast(mostDEgenes, gene ~ type, value.var = mean, fun.aggregate = "mean")  #why did I have to specify "mean" here? Are there duplicates of types? Double check later.
mostDEgene.long <- as.data.frame(mostDEgene.long) #or does not keep column names during transformation.
names(mostDEgene.long)
scale_data <- as.matrix(t(scale(t(mostDEgene.long[c(2:7)]))))
#Principle Component Analysis
pca <- prcomp(scale_data, scale=TRUE)
summary(pca)
pca.scores <- data.frame(pca$x)
data.val <- cbind(allGenes.long, scale_data, pca.scores)
head(data.val)
```
##Visualizing the PCA
There is not clear clustering in these genes. I don't think using all the genes is an appropriate way to find clear patterns in this data.  There is too much noise. I will proceed anyway, to explore how this effects SOM results.
```{r}
p <- ggplot(data.val, aes(PC1, PC2))
p + geom_point(alpha = 0.3)
allGenes <- read.csv("../data/analysis02_geneList.csv")
head(allGenes)
dim(allGenes)
allGenes <- read.csv("../data/analysis02_geneList.csv")
head(allGenes)
dim(allGenes)
plot.data <- read.table("../data/analysis1.som.data.txt",header=TRUE)
names(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(som_cluster))) #notice I am using som_cluster and not unit.classif, because this is the larger SOM
p + geom_point() + theme_bw()
sub_cluster <- subset(plot.data, som_cluster =="5") #Again here I am interested in the clusters made up of many cluster and am not using unit.classif
sub_data <- sub_cluster[,8:13] # just the sample types
names(sub_data)
head(sub_data)
sub_cluster <- subset(plot.data, som_cluster =="5") #Again here I am interested in the clusters made up of many cluster and am not using unit.classif
sub_data <- sub_cluster[,9:14] # just the sample types
names(sub_data)
head(sub_data)
m.data <- melt(sub_data)
head(m.data)
p <- ggplot(m.data, aes(x=variable, y=value))
p + geom_point(alpha=0.5, position="jitter", size=1) + geom_boxplot(alpha=0.75, outlier.size=0)
plot.data <- read.table("../data/analysis1.som.data.txt",header=TRUE)
dim(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(som_cluster)))
#notice I am using som_cluster and not unit.classif, because this is the larger SOMs
p + geom_point() + theme_bw()
mostDEgenes <- read.csv("../data/allGeneListBothGenotypes_analysis5b.csv")
head(mostDEgenes)
mostDEgenes <- mostDEgenes[c(7, 1, 2, 4)] #keep only needed columns (gene, type, mean)
mostDEgene.long <- cast(mostDEgenes, genotype + gene ~ type, value.var = mean, fun.aggregate = "mean")  #why did I have to specify "mean" here? Are there duplicates of types? Double check later.
mostDEgene.long <- as.data.frame(mostDEgene.long)
head(mostDEgene.long)
wt <- subset(mostDEgene.long, genotype == "wt")
tf2 <- subset(mostDEgene.long, genotype == "tf2")
scale_data.wt <- as.matrix(t(scale(t(wt[c(3:8)]))))#transformation.
scale_data.tf2 <- as.matrix(t(scale(t(tf2[c(3:8)]))))#transformation.
scale_data <- rbind(scale_data.wt, scale_data.tf2)
pca <- prcomp(scale_data, scale=TRUE)
summary(pca)
pca.scores <- data.frame(pca$x)
data.val <- cbind(mostDEgene.long, scale_data, pca.scores)
head(data.val)
p <- ggplot(data.val, aes(PC1, PC2))
p + geom_point(alpha = .6)
names(data.val)
som.data <- as.matrix(data.val[,c(9:14)])
head(som.data)
set.seed(5)
som <- som(data=som.data, somgrid(3,2,"hexagonal")) #set SOM size
summary(som)
plot(som, type ="changes")
plot(som, type = "codes")
plot(som, type = "counts")
plot(som, type="dist.neighbours")
head(som$codes)
som$data <- data.frame(som$data) #changed to dataframe to extract column names easier.
data.val.small <- cbind(data.val,som$unit.classif,som$distances)
head(data.val.small)
write.table(data.val.small, file="../data/analysis1.som.data.small.ALLD.txt")
names(data.val.small)
summary(data.val.small)
summary(data.val.small)
plot.data <- read.table("../data/analysis1.som.data.small.ALLC.txt",header=TRUE)
names(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(som.unit.classif))) #use unit.classif for smaller dataset
p + geom_point(alpha = .6) + facet_grid(.~genotype) + theme_bw()
plot.data <- read.table("../data/analysis1.som.data.small.ALLD.txt",header=TRUE)
names(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(som.unit.classif))) #use unit.classif for smaller dataset
p + geom_point(alpha = .6) + facet_grid(.~genotype) + theme_bw()
library(ggplot2)
library(reshape)
library(plyr)
library(kohonen)
p <- ggplot(data.val, aes(PC1, PC2))
p + geom_point()
set.seed(6)
names(data.val)
superSomData <- data.val[,c(1:8)]
tf2 <- subset(superSomData, genotype == "tf2", select = 3:8)
wt <- subset(superSomData, genotype == "wt", select = 3:8)
wt <- as.matrix(wt)
tf2 <- as.matrix(tf2)
sc.wt <- t(scale(t(wt)))
sc.tf2 <- t(scale(t(tf2)))
all.data <- list(sc.wt,sc.tf2)
ssom <- supersom(all.data, somgrid(6, 6, "hexagonal"),weights=c(0.5,0.5))
summary(ssom)
par(mfrow = c(3, 2))
plot(ssom, type ="changes")
plot(ssom, type = "codes")
plot(ssom, type = "counts")
plot(ssom, type = "quality")
data.val <- cbind(data.val,ssom$unit.classif,ssom$distances)
head(data.val)
write.table(data.val, file="../data/ssom.data.analysis5d.txt")
plot.data <- read.table("../data/ssom.data.analysis5d.txt",header=TRUE)
names(plot.data)
dim(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(ssom.unit.classif)))
p + geom_point() + theme_bw()
#Analysis 7 - Getting a closer look at the clusters from the orignal clusters.
##Purpose
To get start to understand the differences in GO categories between the clusters. This is the data from analysis1D.
###Part 1
This will look into the number of genes that are the same between the clusters and the genotypes. With some basic visualization.
Required Libraries
```{r}
library(VennDiagram)
library(ggplot2)
library(reshape)
library(kohonen)
library(goseq)
library(GO.db)
```
###Visualize by Cluster
Read in data used for GO enrichment analysis
```{r}
geneLength <- read.csv("../../../07GO_enrichment/requisiteData/normalized_genes_length.csv")
cate <- read.table("../../../07GO_enrichment/requisiteData/melted.GOTable.txt",header=TRUE)
```
Read in data produced from analysis1D.
```{r}
plot.data <- read.table("../data/analysis1.som.data.small.ALLD.txt",header=TRUE)
names(plot.data)
```
##Cluster Specific analysis
Now I want to take a look at what are is going on exactly in these clusters. The clusters start with the bottom left, which is cluster number 1.
This is a function that makes a boxplot showing the transformed values of expression in the clusters.
```{r}
#clusterVis Function
#displays transformed data in a box plot and
clusterVis <- function(clustNum){
sub_cluster <- subset(plot.data, som.unit.classif==clustNum)
sub_data <- sub_cluster[,9:14] # just the sample types
m.data <- melt(sub_data)
p <- ggplot(m.data, aes(x=variable, y=value))
p + geom_point(alpha=0.5, position="jitter", size=1) + geom_boxplot(alpha=0.75, outlier.size=0)
}
```
Number of genes function, which gives you some basics about the clusters.
```{r}
clusterNum <- function(clustNum){
sub_cluster <- subset(plot.data, som.unit.classif==clustNum)
print(paste("total number of genes in sub cluster is ",
nrow(sub_cluster)
)
)
scwt <- subset(sub_cluster, genotype == "wt")
print(paste("total number of genes in wt cluster is ",
nrow(scwt)
)
)
sctf2 <- subset(sub_cluster, genotype == "tf2")
print(paste("total number of genes in tf2 cluster is ",
nrow(sctf2)
)
)
scIntersect <- as.data.frame(intersect(scwt$gene, sctf2$gene))
print(paste("There are",
length(intersect(scwt$gene, sctf2$gene)),
" that are the same between wt and tf2"
)
)
##Venn Diagram part
grid.newpage()
venn.plot <- draw.pairwise.venn(area1 = nrow(scwt),
area2    = nrow(sctf2),
cross.area = length(intersect(scwt$gene, sctf2$gene)),
scaled       = F,
category     = c("Wildtype", "tf2"),
fill         = c("blue", "red"),
alpha        = 0.3,
lty          = "blank",
cex          = 2,
cat.cex      = 2,
cat.pos      = c(315, 25),
cat.dist     = 0.09,
cat.just     = list(c(-1, -1), c(1, 1)),
ext.pos      = 30,
ext.dist     = -0.05,
ext.length   = 0.85)
grid.draw(venn.plot)
}
```
```{r}
clusterGO <- function(clustNum){
##GO Enrichment on the catergories
#we need to first get the data in the right format.
#First get the list of ITAG,
#sub_cluster
sub_cluster <- subset(plot.data, som.unit.classif==clustNum)
scwt <- subset(sub_cluster, genotype == "wt")
sctf2 <- subset(sub_cluster, genotype == "tf2")
scIntersect <- as.data.frame(intersect(scwt$gene, sctf2$gene))
itag.sc <- as.data.frame(sub_cluster$gene)
colnames(itag.sc)[1] <- "itag"
itag.sc$sc <- 1
#scwt
itag.scwt <- as.data.frame(scwt$gene)
colnames(itag.scwt)[1] <- "itag"
itag.scwt$wt <- 1
#sctf2
itag.sctf2 <- as.data.frame(sctf2$gene)
colnames(itag.sctf2)[1] <- "itag"
itag.sctf2$tf2 <- 1
#Intersect
itag.scIntersect <- as.data.frame(scIntersect[1])
colnames(itag.scIntersect)[1] <- "itag"
itag.scIntersect$intersect <- 1
#Merge all by itag
ITAGmerge <- merge(itag.scIntersect, itag.scwt, by = "itag", all= TRUE)
ITAGmerge <- merge(ITAGmerge, itag.sctf2, by = "itag", all = TRUE)
matrixGO <- merge(ITAGmerge, geneLength, by = "itag", all = TRUE)
matrixGO[is.na(matrixGO)] <- 0
pat <- matrixGO
#Now that we have the data in the right format we can proceed with GO enrichment.
#First specify vector to loop over for each column
sigType <- c("intersect", "wt", "tf2")
for(type in sigType) {
genes = as.integer(pat[,type])
names(genes) = pat$itag
table(genes)
length(genes)
pwf = nullp(genes,bias.data=pat$length)
GO.wall = goseq(pwf,gene2cat = cate)
head(GO.wall)
#This is going to correct for multiple testing.  You can specify the p-value cut-off of GO categories you are interested.
enriched.GO = GO.wall$category[p.adjust(GO.wall$over_represented_pvalue, method = "BH") < 0.05]
enriched.GO
my.GO <- as.character(enriched.GO)
my.GO.table <- Term(my.GO)
my.GO.table
t <- as.matrix(my.GO.table)
print(type) #this is for the knitr document
print(t) #this is for the knitr document
}
}
```
vennDiagram Function:
###Cluster 1
Sub cluster 1 is defined by up regulation of genes in Bmbr, which is the early leaflet region of the terminal leaflet.
```{r}
clusterVis(1)
clusterNum(1)
clusterGO(1)
clusterNum(1)
Read in data used for GO enrichment analysis
```{r}
geneLength <- read.csv("../../../07GO_enrichment/requisiteData/normalized_genes_length.csv")
cate <- read.table("../../../07GO_enrichment/requisiteData/melted.GOTable.txt",header=TRUE)
```
Read in data produced from analysis1D.
```{r}
plot.data <- read.table("../data/ssom.data.analysis5d.txt",header=TRUE)
names(plot.data)
```
##Cluster Specific analysis
Now I want to take a look at what are is going on exactly in these clusters. The clusters start with the bottom left, which is cluster number 1.
This is a function that makes a boxplot showing the transformed values of expression in the clusters.
```{r}
#clusterVis Function
#displays transformed data in a box plot
clusterVis <- function(clustNum){
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
sub_data <- sub_cluster[,c(1, 9:14)] # just the sample types
m.data <- melt(sub_data)
p <- ggplot(m.data, aes(x=variable, y=value, color = genotype))
p + geom_point(alpha=0.5,position="jitter", size=1) +
geom_boxplot(alpha=0.75, outlier.size=0) +
theme_bw()
}
```
```{r}
clusterGO <- function(clustNum){
##GO Enrichment on the catergories
dev.off()
plot.new()
#we need to first get the data in the right format.
#First get the list of ITAG
#sub_cluster
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
itag.sc <- as.data.frame(sub_cluster$gene)
colnames(itag.sc)[1] <- "itag"
itag.sc$sc <- 1
#Since each orthologue between tf2 and wt are represented twice in this set, we have to keep only the unique ITAGs.
itag.sc <- unique(itag.sc) #Check. Should cut the list in half. # dim(itag.sc) before and after
#Merge all by itag
matrixGO <- merge(itag.sc, geneLength, by = "itag", all = TRUE)
matrixGO[is.na(matrixGO)] <- 0
pat <- matrixGO
#Now that we have the data in the right format we can proceed with GO enrichment.
genes = as.integer(pat[,"sc"])
names(genes) = pat$itag
table(genes)
length(genes)
pwf = nullp(genes,bias.data=pat$length)
GO.wall = goseq(pwf,gene2cat = cate)
head(GO.wall)
#This is going to correct for multiple testing.  You can specify the p-value cut-off of GO categories you are interested.
enriched.GO = GO.wall$category[p.adjust(GO.wall$over_represented_pvalue, method = "BH") < 0.05]
enriched.GO
my.GO <- as.character(enriched.GO)
my.GO.table <- Term(my.GO)
my.GO.table
t <- as.matrix(my.GO.table)
print(t) #this is for the knitr document
}
```
```{r}
clusterVis_line <- function(clustNum) {
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
sub_data <- sub_cluster[,c(1, 2, 9:14)] # just the sample types
sub_data <- melt(sub_data)
sub_data <- within(sub_data, lineGroup <- paste(genotype, gene,sep='.'))
ggplot(sub_data, aes(variable, value, group = lineGroup, color =  genotype )) +
geom_line(alpha = .1, (aes(color = factor(genotype)))) +
geom_point(alpha = .0)
}
```
```{r}
#Prereq annotation files for function
annotation1<- read.delim("../../../06diffGeneExp/analysis/data/ITAG2.3_all_Arabidopsis_ITAG_annotations.tsv", header=FALSE)  #Changed to the SGN human readable annotation
colnames(annotation1) <- c("ITAG", "SGN_annotation")
annotation2<- read.delim ("../../../06diffGeneExp/analysis/data/ITAG2.3_all_Arabidopsis_annotated.tsv")
annotation <- merge(annotation1,annotation2, by = "ITAG")
#Only Gene Name and ITAG
annotation <- annotation[,c(1,5)]
```
Function
```{r}
genesInClust <- function(clustNum) {
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
sub_data <- as.data.frame(sub_cluster[,2])
colnames(sub_data) <- "ITAG"
resultsTable <- merge(sub_data,annotation,by = "ITAG", all.x=TRUE)
print(nrow(resultsTable))
#  return(resultsTable <- unique(resultsTable))
return(unique(resultsTable))
}
genesInClust <- function(clustNum, plot.data, annotation) {
sub_cluster <- subset(plot.data, ssom.unit.classif==clustNum)
sub_data <- as.data.frame(sub_cluster[,2])
colnames(sub_data) <- "ITAG"
resultsTable <- merge(sub_data,annotation,by = "ITAG", all.x=TRUE)
print(nrow(unique(resultsTable)))
return(unique(resultsTable))
}
```
clusterVis(1)
clusterVis_line(1)
clusterGO(1)
y <- genesInClust(4, plot.data, annotation)
clusterVis(4)
clusterVis_line(4)
names(plot.data)
dim(plot.data)
p <- ggplot(plot.data, aes(PC1, PC2, colour=factor(ssom.unit.classif)))
p + geom_point() + theme_bw()
plot.data <- read.table("../data/ssom.data.analysis5d.txt",header=TRUE)
plot.data <- read.table("../data/ssom.data.analysis5d.txt",header=TRUE)
clusterVis(4)
clusterVis_line(4)
y <- genesInClust(4, plot.data, annotation)
