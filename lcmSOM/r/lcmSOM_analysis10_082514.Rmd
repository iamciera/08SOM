#Analysis 10 - Comparing clusters

##Purpose 

From the start of these clusters it became apparent that I would have to compare the clusters.  Comaparing the clusters have two purposes

1. Quality of Analysis - To understand how consistant different clusteres are, therefore how conservative the results are.

2. Decrease the amount of interesting genes in clusters by comparing WT SOM with *tf2* superSOM. 



##Caveats

1. While the standard deviation of expression of each gene in each tissue were from the reps were calculated, this was not used when creating the self organized map. 


##Analysis Set-up

Required Libraries

```{r}
library(VennDiagram)
library(ggplot2)
library(reshape)
library(kohonen)
library(goseq)
library(GO.db)
library(knitr)
source("./clusterFunctions.R")
```

Upload that dataset:

```{r}
genes25 <- read.csv("../data/analysis4.top25.csv")
genes25 <- genes25[,c(2,9:14)]
```

```{r}
scale_data <- as.matrix(t(scale(t(genes25[c(2:7)])))) 
pca <- prcomp(scale_data, scale=TRUE) 
summary(pca) 
pca.scores <- data.frame(pca$x)
data.val <- cbind(genes25, scale_data, pca.scores) 
```

##SOM A - large

```{r}
#subset only the scaled gene expression values

set.seed(6)
som <- som(data=scale_data, somgrid(6,6,"hexagonal")) # This is where you change the size of the map
summary(som)
```

###Making dataframe
```{r}
data.val2 <- cbind(data.val,som$unit.classif,som$distances) 
names(data.val2)
##rename 
names(data.val2)[20:21] <- c("unitClassIfA", "distanceA")
```

###SOM B - Small

The only difference is the seed set.

```{r}
set.seed(1)
som <- som(data=scale_data, somgrid(3,2,"hexagonal")) # This is where you change the size of the map
summary(som)

###Connect with previous data

data.val3 <- cbind(data.val2,som$unit.classif,som$distances) 

names(data.val3)[22:23] <- c("unitClassIfB", "distanceB")
```

###Finish with a clear set

```{r}
##Subset only the data I am interested in
data.val4 <- data.val3[,c(1,8:13, 20:23)]
head(data.val4)
```

-------------------------------------------
Attempt 1: Create empty matric and run

```{r}
###buildMatrix

#You first need to build a matrix then loop over original values for population of matrix.
#Maybe build function that sets the size of the matrix?

# first subset unitClassIfA genes 1
  #Loop through how many clusters B has
  #Then sunset the unitClassIfB genes 1
    # place in right area in matrix <- length(intersect(unitClassIfA$gene,unitClassIfB$gene)
  #Then sunset the unitClassIfB genes 2
    #place in right area in matrix <- length(intersect(unitClassIfA$gene,unitClassIfB$gene)
      #repeat  

iterations = 36
variables = 6

output <- matrix(ncol=variables, nrow=iterations)

for (i in 1:iterations) {
  subClusterA <- subset(data.val4, unitClassIfA == i)
      #How the hell do I control this?
  for (j in 1:variables) {
      subClusterB <- subset(data.val4, unitClassIfB == j)
       output[i,j] <- length(intersect(subClusterA$gene, subClusterB$gene))
      }
}
```

Attempt 2: Create empty vector

```{r}
mylist <- list() #create an empty list

for (i in 1:iterations) {
  vec <- numeric(variables) #preallocate a numeric vector
  subClusterA <- subset(data.val4, unitClassIfA == i)
  for (j in 1:variables) { #fill the vector
    subClusterB <- subset(data.val4, unitClassIfB == j)
    vec[j]  <- length(intersect(subClusterA$gene, subClusterB$gene))
  }
mylist[[i]] <- vec #put all vectors in the list
}

df <- do.call("rbind",mylist) #combine all vectors into a matrix

## Did this work?
###Test a few rows
#subClusterA <- subset(data.val4, unitClassIfA == 36)
#subClusterB <- subset(data.val4, unitClassIfB == 3)
#length(intersect(subClusterA$gene, subClusterB$gene))

##Got my mutha fucking matrix, bitches!

---------
